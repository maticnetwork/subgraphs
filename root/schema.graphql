type Checkpoint @entity {
  id: ID!
  proposer: Bytes!
  headerBlockId: BigInt!
  checkpointNumber: BigInt!
  reward: BigInt!
  start: BigInt!
  end: BigInt!
  root: Bytes!
}

type StateSync @entity {
  id: ID!
  stateId: BigInt!
  contract: Bytes!
  data: Bytes!
  transactionHash: Bytes!
  timestamp: BigInt!
}

type StateRegistration @entity {
  id: ID!
  user: Bytes!
  receiver: Bytes!
  sender: Bytes!
}

# This entity will hold everything regarding
# plasma exit
#
# Not all fields are made compulsory due to the fact,
# all steps don't happen at a time, rather they will be async ops
type PlasmaExit @entity {
  # id always created using `plasma-exit-${exitId}`
  id: ID!
  exitId: BigInt!
  exitInitiator: Bytes!
  exitCompleter: Bytes
  token: Bytes!
  amount: BigInt!
  isRegularExit: Boolean!
  exited: Int!
  # exited can take 3 possible values
  # 0 -> exit started
  # 1 -> exit cancelled
  # 2 -> exit completed
  exitStartedTxHash: Bytes!
  exitStartedTimeStamp: BigInt!
  exitCancelledTxHash: Bytes
  exitCancelledTimeStamp: BigInt
  exitCompletedTxHash: Bytes
  exitCompletedTimeStamp: BigInt
}

type PredicateRegistration @entity {
  id: ID!
  tokenType: Bytes!
  predicateAddress: Bytes!
  timestamp: BigInt!
  transactionHash: Bytes!
}

type TokenMapping @entity {
  id: ID!
  rootToken: Bytes!
  childToken: Bytes!
  tokenType: Bytes!
  timestamp: BigInt!
  transactionHash: Bytes!
}

type Validator @entity {
  id: ID!
  validatorID: BigInt!
  signer: Bytes!
  signerPubKey: Bytes!
  reward: BigInt!
  activationEpoch: BigInt!
  deactivationEpoch: BigInt!
  jailEndEpoch: BigInt!
  amount: BigInt! 
  total: BigInt!
  commissionRate: BigInt!
  status: Int!
}
